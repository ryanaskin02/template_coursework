---
title: "Coursework Template"
subtitle: 'MSc in Statistics 2025/26, Imperial College London'
author: "Ryan Askin"
format:
  html:
    toc: true
    highlight: tango
    self-contained: true
    df-print: paged
  pdf: default
format-links: false
bibliography: "MSc_Statistics_coursework_template_quarto.bib" 
---

<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>

```{r setup, include = FALSE, tidy=TRUE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = ""
)
include_solutions <- FALSE
```
```{r setup2, include=FALSE, tidy=TRUE}
require(rmarkdown)
require(knitr)
require(kableExtra)
# Put any library imports and other preamble here.
```

This Rmarkdown document is intended to provide a basic template that you may use throughout the course, and to introduce you to basic functionality of the open-source bookdown R package for writing Rmarkdown documents [@xie2016bookdown].

# Analysis of Palmer Penguins Dataset

In this section, I seek to recreate the analysis done on the Palmer Penguins in order to gain an understanding of the workflow associated with submitting assignments.

## Adding Code Blocks and removing unwanted warnings

Firstly I will install the package and load the dataset. Note that this section of code is shown not hidden and it is not executed. 

```{{r}}
# install.packages("palmerpenguins") if you have not already
# use :: to access data or functions from within a package 
penguins <- palmerpenguins::penguins 
```

Often we will encounter warnings that are unwanted in the report. 

```{r}
library(palmerpenguins)
```

These can be suppressed.

```{{r}}
#| warning: false
library(palmerpenguins)
```


```{r}
#| warning: false
library(palmerpenguins)
```

## To show or not show a code block

Sometimes we want to show a code block, but do not want to execute it every time the file is rendered. This can be very common with installing packages for example

```{{r}}
install.packages("palmerpenguins")
```

```{r}
#| eval: false
install.packages("palmerpengins")
```

And other times we want to execute code and not show it. To do this use #| echo: false. This is common when including tables and plots. 

```{{r}}
#| echo: false
plot(x = penguins$bill_length_mm, 
     y = penguins$bill_depth_mm)
```

```{r}
#| echo: false
plot(x = penguins$bill_length_mm,
y = penguins$bill_depth_mm)
```

## Multiple Outputs

If there are multiple outputs in the same code block, they are often split up in the rendering. 
```{r}
mean(penguins$body_mass_g, na.rm = TRUE)
median(penguins$body_mass_g, na.rm = TRUE)
```

To keep this from happening we can set _results_ to **hold**. 

```{r}
#| results: hold
mean(penguins$body_mass_g, na.rm = TRUE)
median(penguins$body_mass_g, na.rm = TRUE)
```

We now see that the output is included together. 

## Motivating Example

Are all species of penguin the same weight? 

```{r echo=FALSE}
plot(x = penguins$species, 
     y = penguins$body_mass_g, 
     ylab = "Body mass (g)", 
     xlab = "Species",
     col = c(6,3,4))
abline(h = mean(penguins$body_mass_g,na.rm = TRUE), col = 2, lwd = 2)
```


### How many of each species do we have?

```{r echo=FALSE}
species_counts <- table(penguins$species)
knitr::kable(species_counts, col.names = c("Species", "Count"))
```

### What information do we have on the linear model? 

```{r echo =FALSE}
# fit linear model
mass_lm <- lm(formula = body_mass_g ~ 1 + species, penguins)

# extract coefficients and standard errors
mass_lm_coefficients <- summary(mass_lm)$coefficients[,1:2]
mass_lm_coefficients
```

```{r message=FALSE}
knitr::kable(x = mass_lm_coefficients)
```

We can set the row and column names to improve the table. 

```{r message=FALSE, echo=FALSE}
row.names(mass_lm_coefficients) <- c("Intercept", "Chinstrap", "Gentoo")
knitr::kable(
  x = mass_lm_coefficients,
  col.names = c("MLE", "Std. Err"))
```


Finally, we really don't need to be showing all of those decimal places.

```{r message=FALSE}
knitr::kable(
  x = round(mass_lm_coefficients, 2),
  col.names = c("MLE", "Std. Err"))
```

$$
p(x) = \frac{1}{\pi (1 + x^2)}, \quad x \in \mathbb{R}.
$$ {#eq-one}

The cdf associated with @eq-test is given by
$$
  F(x) = \frac{1}{\pi}\arctan(x) + \frac{1}{2}.
$$ {#eq-two}

**Part a.** We apply the inversion method as described by @graham2013stochastic. We first compute the generalised inverse of the cdf @eq-two.  To this end, let $y\in [0,1]$, then

\begin{align}
    y &= F(x), \quad \iff (\#eq:3a) \\
    y &= \frac{1}{\pi}\arctan(x) + \frac{1}{2} \quad \iff \\
    y-\frac{1}{2}  &= \frac{1}{\pi}\arctan(x)  \quad \iff \\
    \pi\left(y-\frac{1}{2}\right)  &= \arctan(x)  \quad \iff \\
    x &= \tan\left(\pi\left(y-\frac{1}{2}\right)\right). 
\end{align}

By the inversion method [@graham2013stochastic], if $Y \sim U[0,1]$, then 

\begin{equation}
  X = \tan\left(\pi\left(Y-\frac{1}{2}\right)\right),
  (\#eq:4)
\end{equation}

```{r, echo=FALSE}

### Question 1a

generate_cauchy_samples <- function(n) {
  # Generate 'n' uniform random numbers between 0 and 1
  u <- runif(n)
  
  # Apply the inverse CDF formula to get Cauchy samples
  samples <- tan(pi * (u - 0.5))  
  return(samples)
}

num_samples = 1000

# Generate samples from the standard Cauchy distribution
cauchy_samples <- generate_cauchy_samples(num_samples)

```


**Part b.**   The empirical cdf based on $N$ samples $x_1, \ldots, x_N$ is defined to be
              $$
                \widehat{F}(t) = \frac{1}{N}\sum_{i = 1}^N \mathbf{1}[x_i \leq t], \quad x\in \mathbb{t}.
              $$
To generate the empirical cdf in R, we perform the following steps:
            
a. Generate $N$ samples from the distribution using the inversion method, as detailed in the previous question.  
b. Sort the samples in ascending order $x_1 \leq x_2 \leq x_3 \leq \ldots \leq x_N$.
c. The empirical CDF at value $x_i$ is given by $i/N$.  


In the following figure we plot the empirical cdf based on 1000 samples (black line), and compare against the analytical cdf (red line).  

```{r echo=FALSE}

### Question 1b

# Sort the samples in ascending order
sorted_samples <- sort(cauchy_samples)

# Calculate the cumulative probabilities for each sample
cumulative_probs <- (1:num_samples) / num_samples

x_values <- seq(-100, 100,  length.out = 1000)
cdf_values <- pcauchy(x_values)

# Plot the empirical CDF
plot(sorted_samples, 
     cumulative_probs, 
     type = "s", 
     xlab = "x", 
     ylab = "Empirical CDF", 
     main = "Empirical CDF of Standard Cauchy Distribution", 
     lwd = 2, lty = 1, xlim = c(-100,100))
lines(x_values, cdf_values, type = "l", 
      xlab = "x", ylab = "CDF", main = "CDF of Standard Cauchy Distribution", 
      col = 'red', lty = 2)
```

**Part c.**  We shall use the samples to compute the empirical cdf for the values $x = 0.5, 1, 10$.  

```{r echo=FALSE}

### Question 1c

calculate_ecdf <- function(x) {
    return(sum(sorted_samples <= x)/num_samples)
}

df <- data.frame(x = c(0.5, 1.0, 10.0), 
                ecdf = c(calculate_ecdf(0.5), 
                         calculate_ecdf(1.0), 
                         calculate_ecdf(10.0))
                )
kbl(df,
    caption = 'Empirical CDF', 
    label = 'ecdf',
    digits = 2) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    font_size = 12)
```


# Code appendix

Rather than re-paste all the code to the appendix, here is a trick which makes the markdown file output all the code (without) execution in the appendix, without any duplication.

Please keep in mind to format the code so that the entire code is clearly visible and does not run into the margins of the pdf version.  

```{r ref.label=knitr::all_labels(), echo = T, eval = F}
```

# References
